let l=0;class v{constructor({numServers:e=1,capacity:t=1/0,arrivalGen:i,serviceGen:h}){this.numServers=e,this.capacity=t,this.arrivalGen=i,this.serviceGen=h,this.clock=0,this.events=[],this.queue=[],this.servers=Array.from({length:e},(s,r)=>({id:r,busy:!1,entity:null})),this.served=0,this.rejected=0,this.totalWait=0,this.totalSystem=0,this.totalArrivals=0,this.history=[],this.waitTimes=[],this.lastHistoryTime=0,this.entities=new Map,l=0}scheduleEvent(e,t,i){const h={time:e,type:t,entityId:i};let s=this.events.length;for(this.events.push(h);s>0;){const r=Math.floor((s-1)/2);if(this.events[r].time<=this.events[s].time)break;[this.events[r],this.events[s]]=[this.events[s],this.events[r]],s=r}}popEvent(){if(this.events.length===0)return null;const e=this.events[0],t=this.events.pop();return this.events.length>0&&(this.events[0]=t,this._siftDown(0)),e}_siftDown(e){const t=this.events.length;for(;;){let i=e;const h=2*e+1,s=2*e+2;if(h<t&&this.events[h].time<this.events[i].time&&(i=h),s<t&&this.events[s].time<this.events[i].time&&(i=s),i===e)break;[this.events[i],this.events[e]]=[this.events[e],this.events[i]],e=i}}start(){this.scheduleFirstArrival()}scheduleFirstArrival(){const e=l++,t=this.arrivalGen();this.scheduleEvent(this.clock+t,"arrival",e)}advanceTo(e){for(;this.events.length>0&&this.events[0].time<=e;){const t=this.popEvent();this.clock=t.time,t.type==="arrival"?this.processArrival(t):t.type==="departure"&&this.processDeparture(t),this.clock-this.lastHistoryTime>=.1&&(this.recordHistory(),this.lastHistoryTime=this.clock)}this.clock=e}processArrival(e){this.totalArrivals++;const t=l++,i=this.arrivalGen();if(this.scheduleEvent(this.clock+i,"arrival",t),this.queue.length+this.servers.filter(n=>n.busy).length>=this.capacity){this.rejected++;return}const s={id:e.entityId,arrivalTime:this.clock,serviceStartTime:null,state:"waiting",serverIndex:null};this.entities.set(s.id,s);const r=this.servers.find(n=>!n.busy);r?this.startService(s,r):this.queue.push(s)}startService(e,t){e.state="serving",e.serviceStartTime=this.clock,e.serverIndex=t.id,t.busy=!0,t.entity=e;const i=this.serviceGen();this.scheduleEvent(this.clock+i,"departure",e.id)}processDeparture(e){const t=this.entities.get(e.entityId);if(!t)return;const i=this.servers[t.serverIndex];i.busy=!1,i.entity=null;const h=t.serviceStartTime-t.arrivalTime,s=this.clock-t.arrivalTime;if(this.totalWait+=h,this.totalSystem+=s,this.served++,this.waitTimes.push(h),this.waitTimes.length>500&&(this.waitTimes=this.waitTimes.slice(-500)),t.state="done",this.entities.delete(t.id),this.queue.length>0){const r=this.queue.shift();this.startService(r,i)}}recordHistory(){const e=this.queue.length,t=this.servers.filter(i=>i.busy).length;this.history.push({time:Math.round(this.clock*100)/100,queueLength:e,systemLength:e+t,serverUtil:t/this.numServers}),this.history.length>1e3&&(this.history=this.history.slice(-1e3))}getSnapshot(){const e=this.servers.filter(s=>s.busy).length,t=this.queue.length,i=this.served>0?this.totalWait/this.served:0,h=this.served>0?this.totalSystem/this.served:0;return{clock:this.clock,queueLength:t,systemLength:t+e,serverUtil:this.numServers>0?e/this.numServers:0,served:this.served,rejected:this.rejected,totalArrivals:this.totalArrivals,avgWait:i,avgSystem:h,avgQueueLength:this.history.length>0?this.history.reduce((s,r)=>s+r.queueLength,0)/this.history.length:0,avgSystemLength:this.history.length>0?this.history.reduce((s,r)=>s+r.systemLength,0)/this.history.length:0,servers:this.servers.map(s=>({id:s.id,busy:s.busy})),queueEntities:this.queue.map(s=>({id:s.id})),servingEntities:this.servers.filter(s=>s.busy&&s.entity).map(s=>({id:s.entity.id,serverIndex:s.id}))}}}function c(a){return-Math.log(1-Math.random())/a}export{v as S,c as e};
